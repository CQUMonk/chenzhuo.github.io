(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{239:function(t,n,a){"use strict";a.r(n);var s=a(0),e=Object(s.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"javascript-闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-闭包","aria-hidden":"true"}},[t._v("#")]),t._v(" JavaScript 闭包")]),t._v(" "),a("p",[t._v("在JavaScript中， "),a("code",[t._v("闭包（closure）")]),t._v("一直是开发者们比较难以理解的概念， 当我们真正理解了JavaScript中关于\n"),a("router-link",{attrs:{to:"/tech/js/js-context.html"}},[t._v("执行上下文")]),t._v("\n的概念后，我们离理解闭包的设计机制就不远了。")],1),t._v(" "),a("p",[t._v("闭包与普通的函数区别在于，它绑定了相应的执行环境，JavaScript的闭包主要包括两个部分：")]),t._v(" "),a("ul",[a("li",[t._v("执行上下文的词法环境")]),t._v(" "),a("li",[t._v("表达式")])]),t._v(" "),a("h2",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("p",[t._v("关于闭包， 我想开发者最懵的就是，外部函数都执行完毕并返回了， 为什么内部函数还可以访问到外部函数中定义的变量呢？")]),t._v(" "),a("p",[t._v("为了理清楚闭包的原理， 我们将闭包相关的执行上下文和作用域链梳理一下， 首先看一个简单的闭包示例：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("outterF")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'outter variable'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("innerF")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" callInnerF"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("outterF")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("callInnerF")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])])]),a("p",[t._v("程序加载运行后， 首先创建"),a("code",[t._v("全局执行上下文")]),t._v("并推入"),a("code",[t._v("执行栈")]),t._v("中。程序首先创建了一个函数"),a("code",[t._v("outterF")]),t._v("和一个变量"),a("code",[t._v("callInnerF")]),t._v("， 此时全局执行上下文所对应的词法环境如下（略去无关内容）：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("globalLexicalEnvironment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    outerEnvironmentRef"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n    environmentRecord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"outterF"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("outterF"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"callInnerF"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),a("p",[t._v("接下来在"),a("code",[t._v("outterF()")]),t._v("函数执行时候， 则创建了对应的函数执行上下文并推入执行栈。\n它所对应的词法环境如下所示：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("outterFLexicalEnvironment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    outterEnvironmentRef"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("globalLexicalEnvironment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n    environmentRecord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'outter variable'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"innerF"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("innerF\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("此时"),a("code",[t._v("执行栈")]),t._v("的栈中包含了"),a("code",[t._v("outterFContext")]),t._v("和"),a("code",[t._v("globalContext")]),t._v("。\n每个执行上下文包含了对应的"),a("code",[t._v("词法环境")]),t._v("，函数"),a("code",[t._v("outterF")]),t._v("的词法环境的"),a("code",[t._v("outterEnvironmentRef")]),t._v("引用指向了外层的全局词法环境"),a("code",[t._v("globalLexicalEnvironment")]),t._v("。")]),t._v(" "),a("p",[t._v("在"),a("code",[t._v("outterF")]),t._v("函数执行过程中创建了"),a("code",[t._v("innerF")]),t._v("函数对象，并作为函数的返回值。\n此时的"),a("code",[t._v("innerF")]),t._v("函数并未执行，只是被声明了出来, 函数对象的"),a("code",[t._v("[[Environment]]")]),t._v("属性指向了"),a("code",[t._v("innerF")]),t._v("函数定义时的词法环境："),a("code",[t._v("outterFLexicalEnvironment")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("outterFLexicalEnvironment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    outterEnvironmentRef"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("globalLexicalEnvironment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n    environmentRecord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'outter variable'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"innerF"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("innerF\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("当"),a("code",[t._v("outterF")]),t._v("执行完毕后， 函数执行上下文出栈并销毁。此时的执行栈中只有全局的执行上下文"),a("code",[t._v("globalContext")]),t._v("。")]),t._v(" "),a("p",[t._v("虽然"),a("code",[t._v("outterF")]),t._v("函数的执行上下文被销毁，但是它所对应的词法环境"),a("code",[t._v("outterFLexicalEnvironment")]),t._v("却没有被销毁。\n因为在"),a("code",[t._v("innerF")]),t._v("函数对象的"),a("code",[t._v("[[Environment]]")]),t._v("属性保存着"),a("code",[t._v("innerF")]),t._v("函数定义时的词法环境——"),a("code",[t._v("outterFLexicalEnvironment")]),t._v("；")]),t._v(" "),a("p",[t._v("这里就是理解闭包本身的关键所在。")]),t._v(" "),a("p",[a("code",[t._v("callInnerF")]),t._v("变量指向了"),a("code",[t._v("outterF")]),t._v("函数的返回值 ——"),a("code",[t._v("innerF")]),t._v("函数。因此， 当执行"),a("code",[t._v("callInnerF()")]),t._v("事实上就是调用执行"),a("code",[t._v("innerF")]),t._v("函数。\n当callInnerF函数执行，JavaScript引擎会为它创建对应的执行上下文和词法环境，并使用"),a("code",[t._v("innerF")]),t._v("函数的"),a("code",[t._v("[[Environment]]")]),t._v("属性初始化callInnerF函数的词法环境：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("callInnerFLexicalEnvironment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    outterEnvironmentRef"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("outterFLexicalEnvironment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n    environmentRecord"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("innerF")]),t._v("中执行打印a变量操作时， 会沿着"),a("code",[t._v("outterEnvironmentRef")]),t._v("形成的作用域链向外查找，并在"),a("code",[t._v("outterFLexicalEnvironment")]),t._v("所指向的environmentRecord中获取到"),a("code",[t._v("a")]),t._v("变量。")]),t._v(" "),a("p",[t._v("这个过程解释了当"),a("code",[t._v("outterF")]),t._v("函数执行完毕，所对应的执行环境销毁，但由于所对应的变量对象还留在内存中， 我们仍然能够访问到它内部的变量"),a("code",[t._v("a")]),t._v(".")]),t._v(" "),a("p",[t._v("当"),a("code",[t._v("innerF")]),t._v("函数执行完毕，它所对应的执行上下文和词法环境才会被销毁。")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("在上面的分析过程后，我们可以简单地理解了闭包的概念，闭包就是一个内部定义的函数可以访问它外部函数中定义的变量和参数， 即便它的外部函数已经执行完毕并返回了结果。")])])}),[],!1,null,null,null);n.default=e.exports}}]);