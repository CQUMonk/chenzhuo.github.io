(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{229:function(t,a,s){"use strict";s.r(a);var n=s(0),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"再见咯，nullpointerexception"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#再见咯，nullpointerexception","aria-hidden":"true"}},[t._v("#")]),t._v(" 再见咯，NullPointerException!")]),t._v(" "),s("p",[t._v("作为一个Java语言的使用者，特别是Android开发人员，一定对NPE深通恶绝。在Java8之前，我们不得不作大量的判空操作，一不留神就是一个Crash！简直了！")]),t._v(" "),s("p",[t._v("那么如何解决这一问题呢？我们知道，当程序试图调用某个对象的方法或者属性变量，然而指向这个对象的引用为null的时候，此时NPE就发生了。一个对象变量为null本身是必要的，也是没有任何问题的，我们只需要保证程序在调用该对象方法的时候不为null即可。")]),t._v(" "),s("p",[t._v("然而，我们对于在程序运行阶段人为地完成大量判空操作不胜其烦，于是，kotlin的设计者将这一检查操作放在了程序的编译阶段：")]),t._v(" "),s("blockquote",[s("p",[t._v("程序的设计者必须保证在调用某对象方法时，该对象值不能为null，否则程序编译无法通过；")])]),t._v(" "),s("p",[t._v("为此，kotlin引入了“Nullable”类型的设计思想：对于任意一种类型的对象T，都对应了一种“Nullable”类型"),s("code",[t._v("T？")]),t._v("，来表示所声明的对象可能为一个T类型的实例，也有可能是null，编译器会保证在未进行检查之前我们无法调用该对象的方法。")]),t._v(" "),s("p",[t._v("例如，我们写了一个方法"),s("code",[t._v("getStrLen")]),t._v("，该方法接收一个字符串对象并返回字符串的长度：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getStrLen")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("str"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("str"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length\n")])])]),s("p",[t._v("此时，我们的字符串入参被声明为"),s("code",[t._v("String")]),t._v("，则kotlin中认为str一定不可能为null；因此如果调用该方法时传入null一定会收到编译器的提示错。")]),t._v(" "),s("p",[t._v("那么，如果我们希望"),s("code",[t._v("getStrLen")]),t._v("方法也能接受null，则要修改入参的“类型”（我们可以理解"),s("code",[t._v("T？")]),t._v("是一种新的类型），并告诉编译器如果str为空如何处理。")]),t._v(" "),s("p",[t._v("这样在逻辑上虽然保证了NPE不会发生，但是对于开发者而言岂不是还要写很多if语句来判空？为此，kotlin引入了若干操作符来提高开发效率：")]),t._v(" "),s("h2",{attrs:{id:"安全访问操作符-“-”"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安全访问操作符-“-”","aria-hidden":"true"}},[t._v("#")]),t._v(" 安全访问操作符 “.?”")]),t._v(" "),s("p",[t._v("安全访问操作符“.?”将判空操作和方法的调用操作结合起来。如果实例对象不为null，则返回方法调用结果，否则返回null。")]),t._v(" "),s("h2",{attrs:{id:"elvis操作符-“-”"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#elvis操作符-“-”","aria-hidden":"true"}},[t._v("#")]),t._v(" Elvis操作符 “?:”")]),t._v(" "),s("p",[t._v("Elvis表达式与三目运算符形状上非常相似，但Elvis表达式只在两侧接收两个参数：如果第一个参数不为空，则返回第一个参数，否则返回第二个参数。")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" String "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?:")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  如果s为null 则返回空串，否则反回s")]),t._v("\n")])])]),s("p",[t._v("因此，Elvis 操作符也经常与安全访问操作符一起搭配使用：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" len "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Int "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" str"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lengh "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?:")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  如果str为null 则返回长度为0")]),t._v("\n")])])]),s("h2",{attrs:{id:"非空断言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非空断言","aria-hidden":"true"}},[t._v("#")]),t._v(" 非空断言 !!")]),t._v(" "),s("p",[t._v("如果我们希望编译器跳过null检查的话，可以使用非空断言：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[t._v("str"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length\n")])])]),s("p",[t._v("但是，如果str真的为null的话，则程序仍会在运行时抛出NPE异常出来。")]),t._v(" "),s("h2",{attrs:{id:"安全的类型转换as"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安全的类型转换as","aria-hidden":"true"}},[t._v("#")]),t._v(" 安全的类型转换as?")]),t._v(" "),s("p",[t._v("在程序运行阶段，如果我们对某个实例对象进行了错误的类型强转，就会发生"),s("code",[t._v("ClassCastException")]),t._v("异常，因此我们不得不在类型强转前进行检查。kotlin提供了安全的类型强转操作符"),s("code",[t._v("as？")]),t._v("：")]),t._v(" "),s("blockquote",[s("p",[t._v("如果发生错误的类型转换，则返回null")])]),t._v(" "),s("h2",{attrs:{id:"let-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#let-函数","aria-hidden":"true"}},[t._v("#")]),t._v(" let 函数")]),t._v(" "),s("p",[t._v("我们经常会遇到这样的场景：如果对象不为空，则调用相应的方法；否则什么也不做。 于是我们的代码中存在着大量的判空逻辑。")]),t._v(" "),s("p",[t._v("kotlin在编译期所进行的null检查可以说是非常严格。即便是我们先对一个实例对象判空，再调用改对象的方法或属性这样的操作，编译器也会认为这样会存在线程安全的问题。")]),t._v(" "),s("p",[t._v("我们当然可以进行通过非空断言的方式来向编译器保证对象绝对不会为null，明显有更优雅的方式：安全访问操作符配合let函数。")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[t._v("a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("let")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("安全访问操作符上面已经介绍过，当a不为null时，才会调用let函数；而let函数所做的操作是将调用对象a本身作为入参传给lambda表达式，这样就保证了a作为非null对象在let函数体内安全使用。")]),t._v(" "),s("h2",{attrs:{id:"延迟初始化关键字lateinit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延迟初始化关键字lateinit","aria-hidden":"true"}},[t._v("#")]),t._v(" 延迟初始化关键字lateinit")]),t._v(" "),s("p",[t._v("在一个kotlin类的实例对象中，通常需要我们在构造函数里完成对所有的属性进行初始化操作。如果某个属性类型是非空的，那么我们必须在构造函数中提供相应的非空对象。")]),t._v(" "),s("p",[t._v("如果我们无法在构造函数中为对应的非空属性进行初始化呢？ 除了用“Nullable”类型加上非空断言的方式之外，还可以利用"),s("code",[t._v("lateinit")]),t._v("关键字将该非空属性声明为延迟初始化。")]),t._v(" "),s("p",[t._v("这样，我们从程序逻辑上来向编译器保证，该属性无需在构造函数内初始化，在运行时访问该属性之前一定会对其完成初始化工作。")]),t._v(" "),s("p",[t._v("当然，如果我们访问一个没有初始化的属性，仍然会抛空指针异常。")])])}),[],!1,null,null,null);a.default=e.exports}}]);