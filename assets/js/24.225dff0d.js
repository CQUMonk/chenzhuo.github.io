(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{230:function(a,t,e){"use strict";e.r(t);var r=e(0),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"尝一口-kotlin-吧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#尝一口-kotlin-吧","aria-hidden":"true"}},[a._v("#")]),a._v(" 尝一口 Kotlin 吧")]),a._v(" "),e("p",[a._v("Google IO 2017 宣布Kotlin将作为Android官方的开发语言后，我也第一时间进行了关注与跟进，并将学习笔记整理在这里。")]),a._v(" "),e("p",[a._v("首先，我们来引用一段来自Wikipedia对于Kotlin的简介：")]),a._v(" "),e("blockquote",[e("p",[a._v("Kotlin is a statically typed programming language that runs on the Java virtual machine and also can be compiled to JavaScript source code or use the LLVM compiler infrastructure.\nWhile the syntax is not compatible with Java, the JVM implementation of Kotlin's standard library is designed to interoperate with Java code and is reliant on Java code from the existing Java Class Library, such as the collections framework.")])]),a._v(" "),e("h2",{attrs:{id:"沿着java的足迹，去到java到不了的地方"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#沿着java的足迹，去到java到不了的地方","aria-hidden":"true"}},[a._v("#")]),a._v(" 沿着Java的足迹，去到Java到不了的地方")]),a._v(" "),e("p",[a._v("从设计之初，设计者们就希望Kotlin能像今天的Java一样应用广泛。因此作为一款JVM语言，无论是在Server端，还是Android手机上，kotlin都可以与Java互相调用，实现已有代码的复用。不仅如此，Kotlin还可以被编译为JavaScript运行在浏览器上，另外也可以用于进行包括iOS在内的其他OS应用程序开发（目前还不多见呢）。")]),a._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",[a._v("“Kotlin的诞生不是有意针对在座的各位编程语言，仅仅就是处处针对Java！ ” 在Kotlin的学习过程中，我仿佛看见Kotlin的设计者们在暗搓搓地吐槽Java有多TM难用.")])]),a._v(" "),e("p",[a._v("作为一门“新”JVM 编程语言，Kotlin 不仅继承了Java在设计上的优点，同时也在语法上吸取了“现代”编程语言的优秀特性。")]),a._v(" "),e("h3",{attrs:{id:"类型推断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型推断","aria-hidden":"true"}},[a._v("#")]),a._v(" 类型推断")]),a._v(" "),e("p",[a._v("与Java一样，Kotlin也是一种"),e("code",[a._v("静态类型")]),a._v("的编程语言，也就是说编译器在编译阶段就可以知道代码中每个表达式结果或者变量的类型，而不是像Groovy（也是一种JVM语言，用gradle的同学应该比较熟悉）那样在代码运行阶段才去判断数据的类型。这样设计的好处可以提前在编译阶段提前发现错误，提高程序运行的速度(无需再运行期间对类型判断)。")]),a._v(" "),e("p",[a._v("而与Java不同的是，Kotlin具有“类型推断”的能力，开发过程中很多时候并不需要开发者显式地指定某个变量的类型，而是通过上下文完成对数据类型进行推断：")]),a._v(" "),e("div",{staticClass:"language-kotlin extra-class"},[e("pre",{pre:!0,attrs:{class:"language-kotlin"}},[e("code",[a._v("int a "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// java")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("var")]),a._v(" b "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// kotlin")]),a._v("\n")])])]),e("p",[a._v("Kotlin的“类型推断”干掉了Java中大理冗余的显式类型声明，让我们的代码看上去更加简洁了..呢。")]),a._v(" "),e("h3",{attrs:{id:"函数式编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程","aria-hidden":"true"}},[a._v("#")]),a._v(" 函数式编程")]),a._v(" "),e("p",[a._v("”函数式编程“是大多数现代编程语言所具有的特性（Java 8也支持），强调程序执行的结果而非执行的过程，其特点在于：")]),a._v(" "),e("ol",[e("li",[a._v("函数本身作为”值“来进行计算和处理，可以被当作变量存取，或者其他函数入参和出参。")]),a._v(" "),e("li",[a._v("作为”值“本身，它具有不可更改的特性，也就是说函数最终输出结果不可更改。")]),a._v(" "),e("li",[a._v("对于函数而言，特定的输入对应于特定的输出，并不会函数之外的其他对象带来改变。")])]),a._v(" "),e("p",[a._v("”函数式编程“不仅仅让我们的代码量大大减少，同时，函数本身作为只读的”值“不可更改，因此也让多线程的同步操作变得安全起来。")]),a._v(" "),e("h2",{attrs:{id:"编译和运行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编译和运行","aria-hidden":"true"}},[a._v("#")]),a._v(" 编译和运行")]),a._v(" "),e("p",[a._v("Kotlin的编译过程与Java基本相同：源文件.kt首先被编译器解析并生成.class文件，随后也被打包为.jar文件。")]),a._v(" "),e("p",[a._v("Java-Kotlin之间的互相转换也都是通过对于相应源文件与.class文件的编译和反编译来完成的。")]),a._v(" "),e("p",[a._v("和Java相似，.kt的编译依赖于"),e("code",[a._v("Kotlin runtime library")]),a._v("，它不仅包括kotlin自己的标准库文件，还对Java标准库所提供的API进行了扩展。")])])}),[],!1,null,null,null);t.default=s.exports}}]);