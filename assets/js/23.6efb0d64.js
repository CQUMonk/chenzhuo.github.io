(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{231:function(t,a,s){"use strict";s.r(a);var n=s(0),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"泛型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#泛型","aria-hidden":"true"}},[t._v("#")]),t._v(" 泛型")]),t._v(" "),s("p",[t._v("我们都知道面向对象的编程语言具有三大特性：封装，继承和多态的特性（抽烟喝酒烫头）。它允许将一个基类的引用指向子类的实例对象：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[t._v("SubClass sub "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SubClass")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nSuperClass superClass"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("sub\n")])])]),s("p",[t._v("继承和多态可以让程序设计变得更为抽象和通用。然而，当我们讨论"),s("code",[t._v("泛型")]),t._v("的时候，由于类型擦除的原因，通常意义上的继承失效了。")]),t._v(" "),s("p",[t._v("泛型机制是通过JVM的类型擦除实现的，无论kotlin还是java，泛型类的实例对象在运行时并不会保存该泛型类的参数类型信息。")]),t._v(" "),s("p",[t._v("例如，我们创建了一个"),s("code",[t._v("List<String>")]),t._v(" 实例对象dataList来存储一组String对象。尽管编译器不会让我们向dataList里面添加其他类型的数据，但在程序运行阶段，该实例对象dataList只是一个List类型的对象，并不知道里面存储的具体对象类型。")]),t._v(" "),s("p",[t._v("由于在运行时JVM无法来判断所操作的参数类型，就有可能带来数据类型不一致的风险，例如：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addData")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("list"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("MutableList"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Any"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("22")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" strList "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mutableListOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"b"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addData")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("strList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 无法编译通过")]),t._v("\n")])])]),s("p",[t._v("在进一步讨论之前，我们需要弄清楚几个特殊的概念")]),t._v(" "),s("ul",[s("li",[t._v("类class和类型type")]),t._v(" "),s("li",[t._v("子类subClass和子类型subtype")]),t._v(" "),s("li",[t._v("型变Variance：协变covariance，逆变contravariance以及非型变关系")])]),t._v(" "),s("p",[t._v("为了便于理解这几个拗口的名词，虽然我使用了业内通用的名词翻译，但是还是觉得没有很好地表现出英文单词的原意。")]),t._v(" "),s("h2",{attrs:{id:"类class-和-类型type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类class-和-类型type","aria-hidden":"true"}},[t._v("#")]),t._v(" 类Class 和 类型Type")]),t._v(" "),s("p",[t._v("无论是Java还是kotlin，通常情况下，我们不会去区分类与类型这两个概念的。类Class我们已经很熟悉了，它是我们为创建的某个对象所定义的模板，而一个变量的类型type是指这个变量本身可存储的值.")]),t._v(" "),s("p",[t._v("一个非常简单的例子就是,定义一个变量str "),s("code",[t._v("var str:String?")]),t._v(" ，它的值可以是一个"),s("code",[t._v("String")]),t._v("类的实例对象，也可以是一个null对象。在我们的认知中，String是通常意义上的类class，而String? 是一种类型type。很明显，kotlin中一个类Class最少对应着两种类型。")]),t._v(" "),s("p",[t._v("对于集合也是一样，List是一个类class，而"),s("code",[t._v("List<String>")]),t._v("并不是一个class，而是一个类型type。")]),t._v(" "),s("h2",{attrs:{id:"子类subclass-和-子类型subtype"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#子类subclass-和-子类型subtype","aria-hidden":"true"}},[t._v("#")]),t._v(" 子类subclass 和 子类型subtype")]),t._v(" "),s("p",[t._v("基类和子类比较容易理解，它是相对于继承这个概念而言的：也就是说如果B是A的子类subclass，那么B需要继承A。\n而要理解子类型subtype的概念则需要举一个具象化的例子：一个变量"),s("code",[t._v("var str:String?")]),t._v("可以保存两种类型的值——String类型和 null类型，我们可以把"),s("code",[t._v("“abc”")]),t._v("和"),s("code",[t._v("null")]),t._v("赋值给str。这里，我们认为String就是String？的子类型，因为可以使用String?的值的地方（可以是非空String值也可以是null值）都可以换成String非空的值。我们似乎可以得出两个结论：")]),t._v(" "),s("ul",[s("li",[t._v("如果B继承了A，那么B是A的子类，也是A的子类型")]),t._v(" "),s("li",[t._v("A是A?的子类型")])]),t._v(" "),s("h2",{attrs:{id:"型变variance与非型变invariance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#型变variance与非型变invariance","aria-hidden":"true"}},[t._v("#")]),t._v(" 型变Variance与非型变Invariance")]),t._v(" "),s("p",[t._v("通常情况下，我们其实并不关心子类和子类型的概念和区别，而在我们讨论泛型的时候，它们的关系就显得十分重要了。")]),t._v(" "),s("p",[t._v("在上面讨论类型擦除的例子中，"),s("code",[t._v("MutableList<Any>")]),t._v(" 与 "),s("code",[t._v("MutableList<String>")]),t._v(" 两个泛型类二者之间并无关系，即便String是Any的子类。")]),t._v(" "),s("p",[t._v("同样，在Java中参数类型之间的关系也不会影响整个泛型类之间的关系，这种也被称为非型变性Invariance。")]),t._v(" "),s("p",[t._v("而我们接下来要聊的型变Variance关系，则描述了泛型类中参数类型存在继承关系时，影响整个泛型类之间的关系的场景：例如"),s("code",[t._v("List<Any>")]),t._v("和"),s("code",[t._v("List<String>")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"协变covariance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协变covariance","aria-hidden":"true"}},[t._v("#")]),t._v(" 协变Covariance")]),t._v(" "),s("p",[t._v("在kotlin中，泛型接口"),s("code",[t._v("List<E>")]),t._v("接口是一种只读列表，创建后无法修改列表内容。如果B类型是A类型的子类型subtype，那么"),s("code",[t._v("List<B>")]),t._v("就是"),s("code",[t._v("List<A>")]),t._v("的子类型subtype。例如：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" strList"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("List"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("String"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("listof")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"aaa"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bbb"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" anyList"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("List"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Any"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" strList\n")])])]),s("p",[t._v("显然，"),s("code",[t._v("List<String>")]),t._v("与"),s("code",[t._v("List<Any>")]),t._v("的关系与参数类型"),s("code",[t._v("String")]),t._v("和"),s("code",[t._v("Any")]),t._v("之间的关系一致，这种性质被称为协变性，显然，"),s("code",[t._v("List<E>")]),t._v("具有可协变性。")]),t._v(" "),s("p",[t._v("那么在Kotlin中如何为泛型声明协变性呢？查看"),s("code",[t._v("List<E>")]),t._v("的定义可以发现：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" List"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("out")]),t._v(" E"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Int"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" E\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("关键字"),s("code",[t._v("out")]),t._v("表示List中的方法只能返回类型E，而不能将类型E作为入参（除了构造函数之外），从而限定了E的协变性。我们在为一个泛型类型声明协变性的时候，务必保证参数类型E相关的引用无法被外界所修改。")]),t._v(" "),s("h3",{attrs:{id:"逆变contravariance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#逆变contravariance","aria-hidden":"true"}},[t._v("#")]),t._v(" 逆变Contravariance")]),t._v(" "),s("p",[t._v("逆变的性质恰好和协变的性质相反，我们换一种泛型类"),s("code",[t._v("Comparator<T>")]),t._v("来介绍逆变：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" anyCompare"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Compare"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Any"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("object")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Compare"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Any"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("override")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("first"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Any"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" second"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Any"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" first"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" second"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("val")]),t._v(" strCompare"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Compare"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("String"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" anyCompare \n")])])]),s("p",[s("code",[t._v("String")]),t._v(" 是 "),s("code",[t._v("Any")]),t._v("的子类型，然而"),s("code",[t._v("Compare<Any>")]),t._v("是"),s("code",[t._v("Compare<String>")]),t._v("的子类型，这样的性质被称为逆变性。而定义泛型类的逆变需要使用in关键字来约束T：")]),t._v(" "),s("div",{staticClass:"language-kotlin extra-class"},[s("pre",{pre:!0,attrs:{class:"language-kotlin"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" Compare"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fun")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compare")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("first"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" second"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Int\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("在Compare的所有方法中，参数类型T只能作为入参存在，不能作为返回值类型。")]),t._v(" "),s("p",[t._v("而如果在Java的泛型类中使用协变和逆变，需要使用泛型类的时候使用通配符?和extends以及super关键字。")]),t._v(" "),s("p",[t._v("可以对比发现kotlin的型变定义在泛型类中，而Java的型变性质则需要使用该泛型类的时候才定义。但是显然在使用时对泛型的型变性质进行约束才更灵活啊，kotlin说好的处处针对Java呢？ 其实kotlin也支持在使用时定义泛型的型变性质。")]),t._v(" "),s("h2",{attrs:{id:"投影"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#投影","aria-hidden":"true"}},[t._v("#")]),t._v(" 投影")]),t._v(" "),s("p",[t._v("之前我们提到过kotlin的可变列表接口"),s("code",[t._v("MutableList<E>")]),t._v("具有非型变性，因为通常情况下MutableList会对其中的元素E的值进行生产（out）与消费（in）操作，也就是说在该接口的定义中，元素E可能作为入参存在，也可能作为返回值。\n如果我们使用时能够保证程序中只使用"),s("code",[t._v("MutableList<E>")]),t._v("中的生产者方法（E作为返回参数）亦或是消费者方法（E作为入参），则可以使用"),s("strong",[t._v("类型投影")]),t._v("的方式在"),s("code",[t._v("MutableList<E>")]),t._v("变量声明的地方使用out或in注解泛型E：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("val list: MutableList<out Number> \n")])])]),s("p",[t._v("这时MutableList就具有了协变性，同时我们无法再使用list的add等方法了。")]),t._v(" "),s("p",[t._v("除了类型投影以外，如果我们实在无法确认泛型参数的类型，可以使用星型投影的方式来声明泛型参数："),s("code",[t._v("List<*>")]),t._v(", 它表示列表中存放的数据类型目前无法确认，但一定是某种特定类型；而List<Any?>则表示List中可以存放任意类型的数据。")])])}),[],!1,null,null,null);a.default=r.exports}}]);